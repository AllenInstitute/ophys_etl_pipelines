import math
from typing import List, Optional, Tuple, Union
import numpy as np
from scipy.sparse import coo_matrix
from ophys_etl.extractors.motion_correction import MotionBorder
from ophys_etl.types import DenseROI, ExtractROI
from skimage.morphology import binary_opening, binary_closing, disk


def full_mask_constructor(mask_matrix: List[List[bool]], x: int, y: int,
                          shape: Tuple[int, int]) -> np.ndarray:
    """make a full-framed mask of the ROI
    Parameters
    ----------
    mask_matrix: List[List[bool]]
        cropped mask
    x: int
        column offset of mask_matrix
    y:
        row offset of mask_matrix
    shape: Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).

    Returns
    -------
    mask: numpy.ndarray
        boolean array, same shape as the input shape

    Notes
    -----
    DenseROI masks are generated by saving only the smallest bounding box that
    contains the ROI as a dense array. This function takes the bounded ROI as
    well as as the x and y top left position of the bounding box and
    regenerates the ROI as it would appear in the original field of view.

    """
    height, width = np.array(mask_matrix).shape
    mask = np.pad(mask_matrix,
                  pad_width=((y, shape[0] - height - y),
                             (x, shape[1] - width - x)),
                  mode='constant')
    return mask


def roi_from_full_mask(roi: DenseROI, mask: np.ndarray
                       ) -> Union[DenseROI, None]:
    """replaces mask and related keys in roi with new mask

    Parameters
    ----------
    roi: DenseROI
        roi for mask replacement
    mask: numpy.ndarray
        boolean, assumed to be full frame

    Returns
    -------
    roi: DenseROI
        roi with mask replaced, or None if mask has no entries

    """
    where = np.where(mask)
    if where[0].size == 0:
        return None
    roi['x'] = int(where[1].min())
    roi['width'] = int(where[1].ptp() + 1)
    roi['y'] = int(where[0].min())
    roi['height'] = int(where[0].ptp() + 1)
    list_mask = []
    for y in range(roi['y'], roi['y'] + roi['height']):
        list_mask.append(mask[y, roi['x']:(roi['x'] + roi['width'])].tolist())
    roi['mask_matrix'] = list_mask
    return roi


def morphological_transform(roi: DenseROI, shape: Tuple[int, int]
                            ) -> Union[DenseROI, None]:
    """performs a closing followed by an opening to clean up pixelated
    appearance of ROIs

    Parameters
    ----------
    roi: DenseROI
        roi to transform
    shape: Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).

    Returns
    -------
    roi: DenseROI
        transformed roi or None if empty after transform

    """

    mask = full_mask_constructor(roi['mask_matrix'], roi['x'], roi['y'], shape)
    structuring_element = disk(radius=1)
    mask = binary_closing(mask, selem=structuring_element)
    mask = binary_opening(mask, selem=structuring_element)
    new_roi = roi_from_full_mask(roi, mask)
    return new_roi


def dense_to_extract(roi: DenseROI) -> ExtractROI:
    """reformat from expected output format from binarization
    to expected input format of extract_traces

    Parameters
    ----------
    roi: DenseROI
        an ROI in the output format of binarization

    Returns
    -------
    exroi: ExtractROI
        an ROI in the input format for extract_traces

    """
    exroi = ExtractROI(
            id=roi['id'],
            x=roi['x'],
            y=roi['y'],
            width=roi['width'],
            height=roi['height'],
            valid=roi['valid_roi'],
            mask=roi['mask_matrix'])
    return exroi


def suite2p_rois_to_coo(suite2p_stats: np.ndarray,
                        movie_shape: Tuple[int, int]) -> List[coo_matrix]:
    """Convert suite2p formatted rois to sparse matrices in COOrdinate format.

    Parameters
    ----------
    suite2p_stats : np.ndarray
        A numpy array loaded from a Suite2P `stat.npy` output file.
        Each element in the array is a dictionary containing information about
        a unique ROI.

        Each ROI dictionary contains the following fields:
        ['ypix', 'lam', 'xpix', 'mrs', 'mrs0', 'compact', 'med', 'npix',
        'footprint', 'npix_norm', 'overlap', 'ipix', 'radius',
        'aspect_ratio', 'skew', 'std']

    movie_shape : Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).

    Returns
    -------
    List[coo_matrix]
        A list of coo matrices. Each matrix represents an ROI.
    """

    coo_rois = [coo_matrix((roi['lam'], (roi['ypix'], roi['xpix'])),
                           shape=movie_shape)
                for roi in suite2p_stats]

    return coo_rois


def binarize_roi_mask(roi_mask: coo_matrix,
                      absolute_threshold: Optional[float] = None,
                      quantile: float = 0.1) -> coo_matrix:
    """Binarize a coo_matrix representing an ROI mask.

    Parameters
    ----------
    roi_mask : coo_matrix
        An ROI mask in coo_matrix format.
    absolute_threshold : Optional[float], optional
        ROI data (Suite2P weights) above and equal to the threshold will be
        set to 1 and set to 0 otherwise. If None is provided, the threshold
        will be determined via quantile. By default None.
    quantile : float, optional
        Compute the specified quantile and use it as the absolute_threshold,
        by default 0.1. This parameter will be ignored if an absolute_threshold
        is provided.

    Returns
    -------
    coo_matrix
        A binarized version of the coo_matrix.
    """
    if absolute_threshold is None:
        absolute_threshold = np.quantile(roi_mask.data, quantile)

    binarized_mask = roi_mask.copy()
    binarized_mask.data = np.where(binarized_mask.data >= absolute_threshold,
                                   1, 0)
    binarized_mask.eliminate_zeros()

    return binarized_mask


def roi_bounds(roi_mask: coo_matrix) -> Union[Tuple[int, int, int, int], None]:
    """Get slicing bounds that define the smallest rectangle that contains
    all nonzero ROI elements.

    Note: An empty roi_mask will return all zero bounds.

    Parameters
    ----------
    roi_mask : coo_matrix
        The ROI for which minimal slicing bounds should be determined.

    Returns
    -------
    Tuple[int, int, int, int]
        Slicing bounds to extract an ROI in the following order:
        (min_row, max_row, min_col, max_col)
        or None if mask is empty
    """

    if roi_mask.row.size == 0 | roi_mask.col.size == 0:
        return None

    min_row = roi_mask.row.min()
    min_col = roi_mask.col.min()
    # Need to add 1 to max indices to get correct slicing upper bound
    max_row = roi_mask.row.max() + 1
    max_col = roi_mask.col.max() + 1

    return (min_row, max_row, min_col, max_col)


def crop_roi_mask(roi_mask: coo_matrix) -> coo_matrix:
    """Crop ROI mask into smallest rectangle that fits all nonzero elements

    Parameters
    ----------
    roi_mask : coo_matrix

    Returns
    -------
    coo_matrix
        A cropped ROI mask or None if coo_matrix is empty

    """

    bounds = roi_bounds(roi_mask)
    if bounds is None:
        return None

    # Convert coo to csr matrix so we can take advantage of indexing
    cropped_mask = roi_mask.tocsr()[bounds[0]:bounds[1], bounds[2]:bounds[3]]

    return cropped_mask.tocoo()


def coo_rois_to_lims_compatible(coo_masks: List[coo_matrix],
                                max_correction_vals: MotionBorder,
                                movie_shape: Tuple[int, int],
                                npixel_threshold: int,
                                ) -> List[DenseROI]:
    """
    Converts coo formatted ROIs to lims compatible format.

    Parameters
    ----------
    coo_masks: List[coo_matrix]
        A list of scipy coo_matrices representing ROI masks, each element of
        list is a unique ROI.
    max_correction_vals: MotionBorder
        Named tuple containing the max motion correction values identified
        in the motion correction step of ophys segmentation pipeline.
        Name tuple has the following names: ['left', 'right', 'up', 'down'].
    movie_shape: Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).
    npixel_threshold: int
        ROIs with fewer pixels than this will be labeled as invalid and small
        size

    Returns
    -------
    List[DenseROI]
        converted rois into LIMS-standard form

    """
    compatible_rois = []
    for temp_id, coo_mask in enumerate(coo_masks):
        compatible_roi = _coo_mask_to_LIMS_compatible_format(coo_mask)
        if compatible_roi is None:
            continue

        compatible_roi['id'] = temp_id  # popped off when writing to LIMs
        compatible_roi['max_correction_up'] = max_correction_vals.up
        compatible_roi['max_correction_down'] = max_correction_vals.down
        compatible_roi['max_correction_right'] = max_correction_vals.right
        compatible_roi['max_correction_left'] = max_correction_vals.left

        labels = _check_exclusion(compatible_roi,
                                  movie_shape,
                                  npixel_threshold)
        compatible_roi['exclusion_labels'] = labels
        compatible_roi['valid_roi'] = not any(labels)

        compatible_rois.append(compatible_roi)

    return compatible_rois


def _coo_mask_to_LIMS_compatible_format(coo_mask: coo_matrix
                                        ) -> Union[DenseROI, None]:
    """
    This functions transforms ROI mask data from COO format
    to the LIMS expected format.
    Parameters
    ----------
    coo_mask: coo_matrix
        The coo roi matrix to be converted

    Returns
    -------
    DenseROI
       or None if the coo_mask is empty

    """
    bounds = roi_bounds(coo_mask)
    if bounds is None:
        return None

    height = bounds[1] - bounds[0]
    width = bounds[3] - bounds[2]
    mask_matrix = crop_roi_mask(coo_mask).toarray()
    mask_matrix = np.array(mask_matrix, dtype=bool)
    compatible_roi = DenseROI(
        x=int(bounds[2]),
        y=int(bounds[0]),
        width=int(width),
        height=int(height),
        mask_matrix=mask_matrix.tolist(),
        # following are placeholders
        valid_roi=True,
        mask_image_plane=0,
        exclusion_labels=[],
        id=-1,
        max_correction_up=-1,
        max_correction_down=-1,
        max_correction_left=-1,
        max_correction_right=-1)
    return compatible_roi


def _motion_exclusion(roi: DenseROI, movie_shape: Tuple[int, int]) -> bool:
    """
    Parameters
    ----------
    roi: DenseROI
        The ROI to check
    movie_shape: Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).

    Returns
    -------
    valid: bool
        True, if the ROI in question does not interesect with a motion
        exclusion area. False if it does.

    """
    # A rightward shift increases the min 'valid' left border of the movie
    l_inset = math.ceil(roi['max_correction_right'])
    # Conversely, a leftward shift reduces the 'valid' right border
    r_inset = math.floor(movie_shape[1] - roi['max_correction_left'])
    t_inset = math.ceil(roi['max_correction_down'])
    b_inset = math.floor(movie_shape[0] - roi['max_correction_up'])

    valid = ((roi['x'] >= l_inset)
             & (roi['x'] + roi['width'] <= r_inset)
             & (roi['y'] >= t_inset)
             & (roi['y'] + roi['height'] <= b_inset))

    return valid


def _small_size_exclusion(roi: DenseROI, npixel_threshold: int) -> bool:
    """
    Parameters
    ----------
    roi: DenseROI
        the ROI to check
    npixel_threshold: int
        ROIs with fewer pixels than this will be labeled as invalid and small
        size

    Returns
    -------
    valid: bool
        whether this ROI is valid on small size exclusion

    """
    npixels = sum([sum(i) for i in roi['mask_matrix']])
    valid = npixels > npixel_threshold
    return valid


def _check_exclusion(compatible_roi: DenseROI,
                     movie_shape: Tuple[int, int],
                     npixel_threshold: int) -> List[str]:
    """
    Check ROI for different possible exclusions

    Parameters
    ----------
    compatible_roi: DenseROI
        the ROI to check
    movie_shape: Tuple[int, int]
        The frame shape of the movie from which ROIs were extracted in order
        of: (height, width).
    npixel_threshold: int
        ROIs with fewer pixels than this will be labeled as invalid and small
        size

    Returns
    -------
    List[str]
        list of exclusion codes, can be empty list

    """
    exclusion_labels = []

    if not _motion_exclusion(compatible_roi, movie_shape):
        exclusion_labels.append('motion_border')

    if not _small_size_exclusion(compatible_roi, npixel_threshold):
        exclusion_labels.append('small_size')

    return exclusion_labels
